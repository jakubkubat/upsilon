//
// Pibero Djawotho <pibero@indiana.edu>
// Indiana University
// 4 October 2006
//
// Revised 3 June 2008
//

// ROOT
#include "TFile.h"
#include "TTree.h"

// STAR
#include "StEventTypes.h"
#include "StMuDSTMaker/COMMON/StMuTypes.hh"
#include "StEmcUtil/geometry/StEmcGeom.h"
#include "StEmcUtil/database/StBemcTables.h"
#include "StEmcUtil/projection/StEmcPosition.h"
#include "StDaqLib/EMC/StEmcDecoder.h"
#include "StEmcRawMaker/defines.h"

// Local
//#include "Quarkonium.hh"
//#include "StUpsilonCandidate.h"
//#include "StUpsilonEvent.h"
#include "StUpsilonTreeMaker.h"

ClassImp(StUpsilonTreeMaker);

int StUpsilonTreeMaker::Init()
{
  mEmcDecoder = new StEmcDecoder;
  mEmcPosition = new StEmcPosition;
  mEmcGeom = StEmcGeom::instance("bemc");
  mBemcTables = new StBemcTables;
  mEmcHits = new TClonesArray("StMuEmcHit", 4801);
  return StMaker::Init();
}

int StUpsilonTreeMaker::InitRun(int runNumber)
{
  mEmcDecoder->SetDateTime(GetDate(), GetTime());
  mBemcTables->loadTables(this);

  // Generate bemcStatus.txt for L2 trigger
  TString bemcStatus = Form("bemcStatus.txt.%s.%d", gSystem->HostName(), gSystem->GetPid());
  makeBemcStatusTable(bemcStatus);

  return StMaker::InitRun(runNumber);
}

void StUpsilonTreeMaker::Clear(Option_t* option)
{
  mEmcHits->Clear(option);
  StMaker::Clear(option);
}

int StUpsilonTreeMaker::Make()
{
  if (!GetDataSet("MuDst")) {
    LOG_WARN << "No MuDst" << endm;
    return kStWarn;
  }

  // Fill array of BEMC ADC and TClonesArray of StMuEmcHit
  unsigned short bemcData[4800];

  for (int softId = 1; softId <= 4800; ++softId) {
    int daqId;
    mEmcDecoder->GetDaqIdFromTowerId(softId, daqId);
    int adc = StMuDst::muEmcCollection()->getTowerADC(softId);
    bemcData[daqId] = adc;
    int status;
    mBemcTables->getStatus(BTOW, softId, status);
    if (status != 1) continue;
    float ped, rms;
    mBemcTables->getPedestal(BTOW, softId, 0, ped, rms);
    if (adc < ped + 3 * rms) continue;
    float calib;
    mBemcTables->getCalib(BTOW, softId, 1, calib);
    float energy = calib * (adc - ped);
    StMuEmcHit* hit = addEmcHit(softId);
    hit->setId(softId);
    hit->setAdc(adc);
    hit->setEnergy(energy);
    hit->setCalType(0);
  }

  return kStOk;
}

int StUpsilonTreeMaker::Finish()
{

  return kStOk;
}

StMuEmcHit* StUpsilonTreeMaker::getEmcHit(int id) const
{
return (StMuEmcHit*)mEmcHits->At(id);
}

StMuEmcHit* StUpsilonTreeMaker::addEmcHit(int id)
{
 return new ((*mEmcHits)[id]) StMuEmcHit;
}

int StUpsilonTreeMaker::makeBemcStatusTable(const char* filename)
{
  ofstream out(filename);
  if (!out) return kStWarn;

  out << "##################################################################################\n";
  out << "# This plain text file contains the complete BEMC trigger configuration\n";
  out << "# Generated by the online BEMC trigger monitoring program on emc01.starp.bnl.gov\n";
  out << "# Timestamp: " << GetDateTime().AsSQLString() << '\n';
  out << "#\n";
  out << "# SoftId\tCrate\tCrate seq\tTower unmasked?\tPatch unmasked in HT?\tPatch unmasked in sum?\tPedestal        triggerPatch\n";

  for (int softId = 1; softId <= 4800; ++softId) {
    int daqId;
    int crate;
    int crateSeq;
    int towerUnmasked;
    int patchUnmaskedInHT;
    int patchUnmaskedInSum;
    float pedestal;
    int patch;

    mEmcDecoder->GetDaqIdFromTowerId(softId, daqId);
    mEmcDecoder->GetTowerCrateFromDaqId(daqId, crate, crateSeq);
    mEmcDecoder->GetTriggerPatchFromCrate(crate, crateSeq, patch);
    mBemcTables->getTriggerPatchStatus(patch, patchUnmaskedInSum);
    mBemcTables->getTriggerHighTowerStatus(patch, patchUnmaskedInHT);
    mBemcTables->getTriggerTowerStatus(crate, crateSeq, towerUnmasked);
    mBemcTables->getTriggerPedestal(crate, crateSeq, pedestal);

    out << "SoftId " << softId << '\t'
        << crate << '\t'
        << crateSeq << '\t'
        << towerUnmasked << '\t'
        << patchUnmaskedInHT << '\t'
        << patchUnmaskedInSum << '\t'
        << pedestal << '\t'
        << patch << '\n';
  }

  out << "#\n";

  int pedestalShift;
  mBemcTables->getTriggerPedestalShift(pedestalShift);

  out << "TriggerPedestalShift " << pedestalShift << '\n';
  out << "#\n";
  out << "# triggerPatch\tCrate\tCrate patch\tUnmasked in HT?\tUnmasked in sum?\tBit conversion mode\tLUT formula and parameters\n";

  for (int crate = 1; crate <= 30; ++crate) {
    for (int cratePatch = 0; cratePatch < 10; ++cratePatch) {
      int crateSeq = cratePatch * 16;
      int patch;
      int unmaskedInHT;
      int unmaskedInSum;
      int bitConvMode;
      int formula;
      int parameters[6];

      mEmcDecoder->GetTriggerPatchFromCrate(crate, crateSeq, patch);
      mBemcTables->getTriggerPatchStatus(patch, unmaskedInSum);
      mBemcTables->getTriggerHighTowerStatus(patch, unmaskedInHT);
      mBemcTables->getTriggerBitConv(crate, cratePatch, bitConvMode);
      mBemcTables->getTriggerFormulaTag(crate, cratePatch, formula);
      mBemcTables->getTriggerFormulaParameters(crate, cratePatch, parameters);

      out << "triggerPatch " << patch << '\t'
          << crate << '\t'
          << cratePatch << '\t'
          << unmaskedInHT << '\t'
          << unmaskedInSum << '\t'
          << bitConvMode << '\t'
          << formula << '\t'
          << parameters[0] << '\t'
          << parameters[1] << '\t'
          << parameters[2] << '\t'
          << parameters[3] << '\t'
          << parameters[4] << '\t'
          << parameters[5] << '\n';
    }
  }

  out << "# End of file\n";
  out << "##################################################################################\n";
  out.close();

  return kStOk;
}

